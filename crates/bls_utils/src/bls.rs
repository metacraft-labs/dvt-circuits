
use bls12_381::{
    hash_to_curve::{ExpandMsgXmd, HashToCurve},
    pairing, G1Affine, G1Projective, G2Affine, G2Projective, Scalar,
};

use dvt_abi;
use sha2::{Sha256};
use std::fmt;

// https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing
//
// In Shamir's secret sharing, a secret is encoded as a n-degree polynomial
// F where the secret value is equal to F(0). Here, F(0) is provided as mask[0].
//
// A key share is generated by evaluating the polynomial in the `id` point.
// Later we can use at least N of these points to recover the original secret.
//
// Furthermore, if we sign some message M with at least K of the secret key
// shares we can restore from them the signature of the same message signed
// with original secret key.
//
// For a more gentle introductiont to Shamir's secret sharing, see also:
//
// https://github.com/dashpay/dips/blob/master/dip-0006/bls_m-of-n_threshold_scheme_and_dkg.md
// https://medium.com/toruslabs/what-distributed-key-generation-is-866adc79620
pub fn evaluate_polynomial(cfs: Vec<G1Affine>, x: Scalar) -> G1Affine {
    let cfst: Vec<G1Projective> = cfs.iter().map(|c| G1Projective::from(c)).collect();
    let count = cfst.len();
    if count == 0 {
        return G1Affine::identity();
    } else if count == 1 {
        return cfs[0];
    } else {
        let mut y = cfst[count - 1];
        for i in 2..(count + 1) {
            y = y * x + cfs[count - i];
        }
        return G1Affine::from(y);
    }
}

pub fn lagrange_interpolation(y_vec: &Vec<G1Affine>, x_vec: &Vec<Scalar>) -> Result<G1Affine, Box<dyn std::error::Error>> {
    let k = x_vec.len();
    if k == 0 || k != y_vec.len() {
        return Err(Box::new(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "invalid inputs",
        )));
    }
    if k == 1 {
        return Ok(y_vec[0]);
    }

    // We calculate L(0) so we can simplify
    // (X - X0) .. (X - Xj-1) * (X - Xj+1) .. (X - Xk) to just X0 * X1 .. Xk
    // Later we can divide by Xi for each basis polynomial li(0)
    let mut a = x_vec[0];
    for i in 1..k {
        a *= x_vec[i];
    }
    if a == Scalar::zero() {
        return Err(Box::new(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "zero secret share id",
        )));
    }
    let mut r = G1Projective::identity();
    for i in 0..k {
        let mut b = x_vec[i];
        for j in 0..k {
            if j != i {
                let v = x_vec[j] - x_vec[i];
                if v == Scalar::zero() {
                    return Err(Box::new(std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        "duplicate secret share id",
                    )));
                }
                b *= v;
            }
        }
        let li0 = a * b.invert().unwrap();
        let tmp = y_vec[i] * li0;
        r = r + tmp;
    }
    Ok(G1Affine::from(r))
}

pub fn hash_message_to_g2(msg: &[u8], domain: &[u8]) -> G2Projective {
    <G2Projective as HashToCurve<ExpandMsgXmd<Sha256>>>::hash_to_curve([msg], domain)
}

pub fn bls_verify(pubkey: &G1Affine, signature: &G2Affine, message: &[u8]) -> bool {
    let domain = b"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_";
    let pk_projective = G1Projective::from(pubkey);
    let sig_projective = G2Projective::from(signature);

    let hashed_msg = hash_message_to_g2(message, domain);
    let left = pairing(&G1Affine::from(pk_projective), &G2Affine::from(hashed_msg));
    let right = pairing(&G1Affine::generator(), &G2Affine::from(sig_projective));

    left == right
}

pub fn bls_id_from_u32(id: u32) -> Scalar {
    let unwrapped_le: [u8; 4] = (id as u32).to_le_bytes();   
    let mut bytes = [0u8; 32];
    bytes[..4].copy_from_slice(&unwrapped_le);
    Scalar::from_bytes(&bytes).unwrap()
}

#[derive(PartialEq)]
pub struct PublicKey {
    key: G1Affine,
}

#[derive(PartialEq)]
pub struct SecretKey {
    key: Scalar,
}

impl PublicKey {
    pub fn to_hex(&self) -> String {
        hex::encode(self.key.to_compressed())
    }

    pub fn from_bytes(bytes: &dvt_abi::BLSPubkey) -> Result<PublicKey, Box<dyn std::error::Error>> {
        let g1 = G1Affine::from_compressed(&bytes).into_option();
        match g1 {
            Some(g1) => Ok(PublicKey { key: g1 }),
            None => Err(Box::new(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Invalid public key",
            ))),
        }
    }

    pub fn from_g1(g1: &G1Affine) -> PublicKey {
        PublicKey { key: *g1 }
    }

    pub fn verify_signature(&self, message: &[u8], signature: &dvt_abi::BLSSignature) -> bool {
        bls_verify(
            &self.key,
            &G2Affine::from_compressed(signature).into_option().unwrap(),
            message,
        )
    }

    pub fn eq(&self, g1: &G1Affine) -> bool {
        self.key == *g1
    }
}

impl SecretKey {
    pub fn to_public_key(&self) -> PublicKey {
        PublicKey {
            key: G1Affine::from(G1Affine::generator() * self.key),
        }
    }

    pub fn from_bytes(bytes: &[u8; 32]) -> Result<SecretKey, Box<dyn std::error::Error>> {
        let mut le_bytes = bytes.clone();
        le_bytes.reverse();

        let sk = Scalar::from_bytes(&le_bytes);

        if sk.is_none().into() {
            return Err(Box::new(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Invalid secret key",
            )));
        }

        Ok(SecretKey { key: sk.unwrap() })
    }

    pub fn to_bytes(&self) -> [u8; 32] {
        self.key.to_bytes()
    }
}


impl fmt::Debug for PublicKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "PublicKey({})", self.to_hex())
    }
}

impl fmt::Debug for SecretKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "SecretKey({})", hex::encode(self.to_bytes()))
    }
}
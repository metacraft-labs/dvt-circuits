use bls12_381::{G1Affine, G1Projective, Scalar};
use std::fmt;

use crate::{bls_id_from_u32, to_g1_affine, BLSPubkeyRaw, HexConvertible};

use crate::types::BLSIdRaw;

pub trait TScalar: Clone + Copy {
    type RawBytes: HexConvertible;
    fn mul(self, other: &Self) -> Self;
    fn mul_assign(&mut self, other: &Self) {
        *self = self.mul(other);
    }
    fn sub(self, other: &Self) -> Self;
    fn is_zero(self) -> bool;
    fn invert(self) -> Self;
    fn from_u32(x: u32) -> Self;

    // fn from_raw_bytes(bytes: &Self::RawBytes) -> Self;
    fn to_raw_bytes(self) -> Self::RawBytes;
}

pub trait TPoint: Clone + Copy {
    type Scalar: TScalar;
    type RawBytes: HexConvertible;
    fn identity() -> Self;

    fn add(self, other: &Self) -> Self;
    fn mul_scalar(self, other: &Self::Scalar) -> Self;
    fn from_raw_bytes(bytes: &Self::RawBytes) -> Self;
    fn to_raw_bytes(self) -> Self::RawBytes;
}

#[derive(Clone, Copy, PartialEq)]
pub struct BlsG1 {
    pub g1: G1Affine,
}

#[derive(Clone, Copy, PartialEq)]
pub struct BlsScalar {
    pub scalar: Scalar,
}

impl TScalar for BlsScalar {
    type RawBytes = BLSIdRaw;

    fn mul(self, other: &Self) -> Self {
        BlsScalar {
            scalar: self.scalar * other.scalar,
        }
    }

    fn sub(self, other: &Self) -> Self {
        BlsScalar {
            scalar: self.scalar - other.scalar,
        }
    }

    fn is_zero(self) -> bool {
        self.scalar == Scalar::zero()
    }

    fn invert(self) -> Self {
        Self {
            scalar: self.scalar.invert().expect("invalid scalar"),
        }
    }

    fn from_u32(x: u32) -> Self {
        BlsScalar {
            scalar: bls_id_from_u32(x),
        }
    }

    // fn from_raw_bytes(bytes: &Self::RawBytes) -> Self {
    //     let mut le_bytes: Self::RawBytes = *bytes;
    //     le_bytes.reverse();
    //     BlsScalar {
    //         scalar: Scalar::from_bytes(&le_bytes).expect("invalid scalar"),
    //     }
    // }

    fn to_raw_bytes(self) -> Self::RawBytes {
        let mut be_bytes = self.scalar.to_bytes();
        be_bytes.reverse();
        Self::RawBytes::from(be_bytes)
    }
}

impl fmt::Display for BlsScalar {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.to_raw_bytes().to_hex())
    }
}

impl TPoint for BlsG1 {
    type Scalar = BlsScalar;
    type RawBytes = BLSPubkeyRaw;
    fn identity() -> Self {
        BlsG1 {
            g1: G1Affine::identity(),
        }
    }

    fn add(self, other: &Self) -> Self {
        let gp1 = G1Projective::from(self.g1);
        let ogp1 = G1Projective::from(other.g1);
        Self {
            g1: G1Affine::from(gp1 + ogp1),
        }
    }

    fn mul_scalar(self, other: &Self::Scalar) -> Self {
        let gp1 = G1Projective::from(self.g1);
        Self {
            g1: G1Affine::from(gp1 * other.scalar),
        }
    }

    fn from_raw_bytes(bytes: &Self::RawBytes) -> Self {
        BlsG1 {
            g1: to_g1_affine(bytes),
        }
    }

    fn to_raw_bytes(self) -> Self::RawBytes {
        Self::RawBytes::from(self.g1.to_compressed())
    }
}

impl fmt::Display for BlsG1 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.to_raw_bytes().to_hex())
    }
}

pub trait Curve {
    type Scalar: TScalar;
    type Point: TPoint<Scalar = Self::Scalar>;
}

pub struct BlsG1Curve {}

impl Curve for BlsG1Curve {
    type Point = BlsG1;
    type Scalar = BlsScalar;
}

// https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing
//
// In Shamir's secret sharing, a secret is encoded as a n-degree polynomial
// F where the secret value is equal to F(0). Here, F(0) is provided as mask[0].
//
// A key share is generated by evaluating the polynomial in the `id` point.
// Later we can use at least N of these points to recover the original secret.
//
// Furthermore, if we sign some message M with at least K of the secret key
// shares we can restore from them the signature of the same message signed
// with original secret key.
//
// For a more gentle introductiont to Shamir's secret sharing, see also:
//
// https://github.com/dashpay/dips/blob/master/dip-0006/bls_m-of-n_threshold_scheme_and_dkg.md
// https://medium.com/toruslabs/what-distributed-key-generation-is-866adc79620
pub fn evaluate_polynomial<C: Curve>(cfs: &[C::Point], x: &C::Scalar) -> C::Point {
    let count = cfs.len();
    if count == 0 {
        C::Point::identity()
    } else if count == 1 {
        cfs[0]
    } else {
        let mut y = cfs[count - 1];
        for i in 2..(count + 1) {
            y = y.mul_scalar(x);
            y = y.add(&cfs[count - i]);
        }
        y
    }
}

#[allow(clippy::assign_op_pattern)]
#[allow(clippy::needless_range_loop)]
pub fn lagrange_interpolation<C: Curve>(
    y_vec: &[C::Point],
    x_vec: &[C::Scalar],
) -> Result<C::Point, Box<dyn std::error::Error>> {
    let k = x_vec.len();
    if k == 0 || k != y_vec.len() {
        return Err(Box::new(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "invalid inputs",
        )));
    }
    if k == 1 {
        return Ok(y_vec[0]);
    }

    // We calculate L(0) so we can simplify
    // (X - X0) .. (X - Xj-1) * (X - Xj+1) .. (X - Xk) to just X0 * X1 .. Xk
    // Later we can divide by Xi for each basis polynomial li(0)
    let mut a = x_vec[0];
    for i in 1..k {
        //a *= x_vec[i];
        a.mul_assign(&x_vec[i]);
    }
    if a.is_zero() {
        return Err(Box::new(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "zero secret share id",
        )));
    }
    let mut r = C::Point::identity();
    for i in 0..k {
        let mut b = x_vec[i];
        for j in 0..k {
            if j != i {
                let v = x_vec[j].sub(&x_vec[i]);
                if v.is_zero() {
                    return Err(Box::new(std::io::Error::new(
                        std::io::ErrorKind::InvalidData,
                        "duplicate secret share id",
                    )));
                }
                b.mul_assign(&v);
            }
        }
        let li0 = a.mul(&b.invert());
        let tmp = y_vec[i].mul_scalar(&li0);
        r = r.add(&tmp);
    }
    Ok(r)
}

#[allow(clippy::assign_op_pattern)]
pub fn agg_coefficients<C: Curve>(
    verification_vectors: &[Vec<C::Point>],
    ids: &[C::Scalar],
) -> Vec<C::Point> {
    let mut final_cfs = Vec::new();
    for i in 0..verification_vectors[0].len() {
        let mut sum = C::Point::identity();
        for v in verification_vectors {
            sum = sum.add(&v[i]);
        }
        final_cfs.push(sum);
    }
    let mut final_keys = Vec::new();
    for id in ids.iter() {
        let tmp = evaluate_polynomial::<C>(&final_cfs, id);
        final_keys.push(tmp);
    }
    final_keys
}

#[cfg(test)]
mod tests {
    use crate::crypto::*;
    use crate::types::*;
    use bls12_381::*;

    use super::*;

    #[test]
    fn test_verify_signature() {
        let data = hex::decode("2f901d5cec8722e44afd59e94d0a56bf1506a72a0a60709920aad714d1a2ece0")
            .unwrap();
        let pk: BLSPubkeyRaw = hex::decode("90346f9c5f3c09d96ea02acd0220daa8459f03866ed938c798e3716e42c7e033c9a7ef66a10f83af06d5c00b508c6d0f").unwrap().try_into().unwrap();
        let sig:BLSSignatureRaw = hex::decode("a9c08eff13742f78f1e5929888f223b5b5b12b4836b5417c5a135cf24f4e2a4c66a6cdef91be3098b7e7a6a63903b61302e3cf2b8653101da245cf01a8d82b25debe7b18a3a2eb1778f8628fd2c59c8687f6e048a31250fbc2804c20043b8443").unwrap().try_into().unwrap();
        let pk = G1Affine::from_compressed(&pk).into_option().unwrap();
        let sig = G2Affine::from_compressed(&sig).into_option().unwrap();
        assert!(bls_verify(&pk, &sig, &data));

        let invalida_data = hex::decode("00").unwrap();
        assert!(!bls_verify(&pk, &sig, &invalida_data));

        let wrong_pk: BLSPubkeyRaw = hex::decode("98876a81fe982573ec5f986956bf9bf0bcb5349d95c3c8da0aefd05a49fea6215f59b0696f906547baed90ab245804e8").unwrap().try_into().unwrap();
        let wrong_pk = G1Affine::from_compressed(&wrong_pk).into_option().unwrap();
        assert!(!bls_verify(&wrong_pk, &sig, &data));

        let bad_sig: BLSSignatureRaw = hex::decode("999e7b24bee2587d687e8f358ed10627ef57ec54935bd7a500bbbb18a57e7aa21b800f8b1f487a980d7c93918fdbd8020b66ce9a9e5788a4826e610ac937d8c2ce0ad9c0ee9a5732cf73052493e9a500cc5100a15bdbf9e5b79104db52dbf07c").unwrap().try_into().unwrap();
        let bad_sig = G2Affine::from_compressed(&bad_sig).into_option().unwrap();
        assert!(!bls_verify(&pk, &bad_sig, &data))
    }

    #[test]
    fn test_evaluate_polynomial() {
        let pks: Vec<BlsG1> = [
            "92cad77a95432bc1030d81b5465cb69be672c1dd0da752230bf8112f8449b03149e7fa208a6fae460a9f0a1d5bd175e9",
            "98876a81fe982573ec5f986956bf9bf0bcb5349d95c3c8da0aefd05a49fea6215f59b0696f906547baed90ab245804e8",
            "ad2c4e5b631fbded449ede4dca2d040b9c7eae58d1e73b3050486c1ba22c15a92d9ff13c05c356f974447e4fca84864a"]
        .iter().map(|pk| -> BLSPubkeyRaw {
            hex::decode(pk).unwrap().try_into().unwrap()
        })
        .map(|pk| BlsG1{ g1: G1Affine::from_compressed(&pk).into_option().unwrap() }).collect();

        let target = "af8e0095ecc662f65b95ce57e5bd2f8739ff93b0621a1ad53f5616538d1323ff40e6e9ddd7132298710974fe6fc0344e";

        let id = BlsScalar::from_u32(1);

        let result = evaluate_polynomial::<BlsG1Curve>(&pks, &id).g1;

        assert!(hex::encode(result.to_compressed()) == target);
    }

    #[test]
    fn test_evaluate_polynomial_bad_base_keys() {
        let pks: Vec<BlsG1> = [
            "92cad77a95432bc1030d81b5465cb69be672c1dd0da752230bf8112f8449b03149e7fa208a6fae460a9f0a1d5bd175e9",
            "92cad77a95432bc1030d81b5465cb69be672c1dd0da752230bf8112f8449b03149e7fa208a6fae460a9f0a1d5bd175e9",
            "92cad77a95432bc1030d81b5465cb69be672c1dd0da752230bf8112f8449b03149e7fa208a6fae460a9f0a1d5bd175e9"]
        .iter().map(|pk| -> BLSPubkeyRaw {
            hex::decode(pk).unwrap().try_into().unwrap()
        })
        .map(|pk| BlsG1{ g1: G1Affine::from_compressed(&pk).into_option().unwrap() }).collect();

        let target = "af8e0095ecc662f65b95ce57e5bd2f8739ff93b0621a1ad53f5616538d1323ff40e6e9ddd7132298710974fe6fc0344e";

        let id = BlsScalar::from_u32(1);

        let result = evaluate_polynomial::<BlsG1Curve>(&pks, &id).g1;

        assert!(hex::encode(result.to_compressed()) != target);
    }

    #[test]
    fn test_lagrange_interpolation() {
        let pks: Vec<BlsG1> = [
            "8da434e68daef9af33e39ab727557a3cd86d7991cd6b545746bf92c8edec37012912cfa2292a21512bce9040a1c0e502",
            "a3cd061aab6013f7561978959482d79e9ca636392bc94d4bcad9cb6f90fe2cdf52100f211052f1570db0ca690b6a9903",
            "8cbfb6cb7af927cfe5fb17621df7036de539b7ff4aa0620cdc218d6b7fe7f2e714a96bdeddb2a0dc24867a90594427e1",
            "9892b390d9d3000c7bf04763006fbc617b7ba9c261fff35094aec3f43599f2c254ae667d9ba135747309b77cd02f1fbc",
            "b255c8a66fd1a13373537e8a4ba258f4990c141fc3c06daccda0711f5ebaffc092f0e5b0e4454e6344e2f97957be4017"]
        .iter().map(|pk| -> BLSPubkeyRaw {
            hex::decode(pk).unwrap().try_into().unwrap()
        })
        .map(|pk| BlsG1{ g1: G1Affine::from_compressed(&pk).into_option().unwrap()}).collect();

        let target = "a31d9a483703cd0da9873e5e76b4de5f7035d0a73d79b3be8667daa4fc7065a1bbb5bf77787fcf2a35bd327eecc4fa6b";

        let ids = vec![
            BlsScalar::from_u32(1),
            BlsScalar::from_u32(2),
            BlsScalar::from_u32(3),
            BlsScalar::from_u32(4),
            BlsScalar::from_u32(5),
        ];

        let result = lagrange_interpolation::<BlsG1Curve>(&pks, &ids).unwrap().g1;

        assert!(hex::encode(result.to_compressed()) == target);
    }

    #[test]
    fn test_lagrange_interpolation_out_of_order() {
        let pks: Vec<BlsG1> = [
            "b255c8a66fd1a13373537e8a4ba258f4990c141fc3c06daccda0711f5ebaffc092f0e5b0e4454e6344e2f97957be4017",
            "8da434e68daef9af33e39ab727557a3cd86d7991cd6b545746bf92c8edec37012912cfa2292a21512bce9040a1c0e502",
            "a3cd061aab6013f7561978959482d79e9ca636392bc94d4bcad9cb6f90fe2cdf52100f211052f1570db0ca690b6a9903",
            "8cbfb6cb7af927cfe5fb17621df7036de539b7ff4aa0620cdc218d6b7fe7f2e714a96bdeddb2a0dc24867a90594427e1",
            "9892b390d9d3000c7bf04763006fbc617b7ba9c261fff35094aec3f43599f2c254ae667d9ba135747309b77cd02f1fbc",
            ]
        .iter().map(|pk| -> BLSPubkeyRaw {
            hex::decode(pk).unwrap().try_into().unwrap()
        })
        .map(|pk| BlsG1{ g1: G1Affine::from_compressed(&pk).into_option().unwrap()}).collect();

        let target = "a31d9a483703cd0da9873e5e76b4de5f7035d0a73d79b3be8667daa4fc7065a1bbb5bf77787fcf2a35bd327eecc4fa6b";

        let ids = vec![
            BlsScalar::from_u32(5),
            BlsScalar::from_u32(1),
            BlsScalar::from_u32(2),
            BlsScalar::from_u32(3),
            BlsScalar::from_u32(4),
        ];

        let result = lagrange_interpolation::<BlsG1Curve>(&pks, &ids).unwrap().g1;

        assert!(hex::encode(result.to_compressed()) == target);
    }

    #[test]
    fn test_lagrange_interpolation_wrong_order() {
        let pks: Vec<BlsG1> = [
            "a3cd061aab6013f7561978959482d79e9ca636392bc94d4bcad9cb6f90fe2cdf52100f211052f1570db0ca690b6a9903",
            "8da434e68daef9af33e39ab727557a3cd86d7991cd6b545746bf92c8edec37012912cfa2292a21512bce9040a1c0e502",
            "8cbfb6cb7af927cfe5fb17621df7036de539b7ff4aa0620cdc218d6b7fe7f2e714a96bdeddb2a0dc24867a90594427e1",
            "9892b390d9d3000c7bf04763006fbc617b7ba9c261fff35094aec3f43599f2c254ae667d9ba135747309b77cd02f1fbc",
            "b255c8a66fd1a13373537e8a4ba258f4990c141fc3c06daccda0711f5ebaffc092f0e5b0e4454e6344e2f97957be4017"]
        .iter().map(|pk| -> BLSPubkeyRaw {
            hex::decode(pk).unwrap().try_into().unwrap()
        })
        .map(|pk| BlsG1{ g1: G1Affine::from_compressed(&pk).into_option().unwrap()}).collect();

        let target = "a31d9a483703cd0da9873e5e76b4de5f7035d0a73d79b3be8667daa4fc7065a1bbb5bf77787fcf2a35bd327eecc4fa6b";

        let ids = vec![
            BlsScalar::from_u32(1),
            BlsScalar::from_u32(2),
            BlsScalar::from_u32(3),
            BlsScalar::from_u32(4),
            BlsScalar::from_u32(5),
        ];

        let result = lagrange_interpolation::<BlsG1Curve>(&pks, &ids).unwrap().g1;

        assert!(hex::encode(result.to_compressed()) != target);
    }

    #[test]
    fn test_lagrange_interpolation_wrong_base_keys() {
        let pks: Vec<BlsG1> = [
            "a3cd061aab6013f7561978959482d79e9ca636392bc94d4bcad9cb6f90fe2cdf52100f211052f1570db0ca690b6a9903",
            "a3cd061aab6013f7561978959482d79e9ca636392bc94d4bcad9cb6f90fe2cdf52100f211052f1570db0ca690b6a9903",
            "a3cd061aab6013f7561978959482d79e9ca636392bc94d4bcad9cb6f90fe2cdf52100f211052f1570db0ca690b6a9903",
            "a3cd061aab6013f7561978959482d79e9ca636392bc94d4bcad9cb6f90fe2cdf52100f211052f1570db0ca690b6a9903",
            "a3cd061aab6013f7561978959482d79e9ca636392bc94d4bcad9cb6f90fe2cdf52100f211052f1570db0ca690b6a9903"]
        .iter().map(|pk| -> BLSPubkeyRaw {
            hex::decode(pk).unwrap().try_into().unwrap()
        })
        .map(|pk| BlsG1{ g1: G1Affine::from_compressed(&pk).into_option().unwrap()}).collect();

        let target = "a31d9a483703cd0da9873e5e76b4de5f7035d0a73d79b3be8667daa4fc7065a1bbb5bf77787fcf2a35bd327eecc4fa6b";

        let ids = vec![
            BlsScalar::from_u32(1),
            BlsScalar::from_u32(2),
            BlsScalar::from_u32(3),
            BlsScalar::from_u32(4),
            BlsScalar::from_u32(5),
        ];

        let result = lagrange_interpolation::<BlsG1Curve>(&pks, &ids).unwrap().g1;

        assert!(hex::encode(result.to_compressed()) != target);
    }
}
